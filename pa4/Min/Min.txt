一. 所使用数据结构与算法的构思、原理和实现要点。
1.所使用的数据结构：优先级队列(priority queue)
2.算法的构思、原理和实现要点：如果不考虑空间的问题，对所有的n个数字全部读进来之后进行全排序之后取秩为k的元素即可，但是空间上肯定就超要求了。因为k不超过50000，50000个整数占用的空间大小为0.2mb左右，满足空间要求。
因此可以维护一个规模为k的大顶堆，先读取n个元素的前k个建堆。对于余下的n-k个元素逐个读取并且和堆顶元素进行比较，若读取的元素a小于堆顶元素b，说明当前的堆顶元素b在全集中的秩至少是k+1了，就需要摘除当前堆顶元素b，代替为
新读取的元素a，接着对a做一次下滤维护堆的性质。若a不小于b，则不需要对堆进行修改，当前堆顶b仍然具备第k大的潜质。该算法的不变性可容易得到：每次操作后堆顶元素始终是已读取的所有元素中第k大的，元素读取完毕以后也是如此，
因此剩下的n-k个元素全部逐个和各自对应状态下的堆顶比较并且操作之后，整个堆的堆顶就是所有n个元素中第k大的。
实现要点：1.建堆的时候需要使用Floyd法建堆保证在线性的时间内完成建堆。
2.要做好堆中叶子节点的判定，防止下滤的时候发生数组越界。
二. 完成过程中遇到的问题，排除问题的主要过程、使用的方法和技巧，以及参考资料。
问题1：使用了setvbuf函数扩大缓冲区后始终超空间。后面发现提交空文件已经占用了12mb左右的空间，而总体要求是不超过13mb，函数中输入输出缓冲区各自扩大的操作是new char[1<<20],这就必定总共占据了2mb，超空间是必定的。于是
干脆就直接fread读取不扩大缓冲区了。
问题2：后续的n-k个元素逐个从外存读取到内存中，耗费在I/O上的时间会比较多。可以充分利用除了堆之外还可以利用的空间，一次性尽可能多地将剩下的元素先大规模读取到内存中，使用完了再大规模读取直到读完，这样可以减少I/O次数。取
100000作为每次读取剩余元素的数量，因为100000个整数大小为0.4mb左右，和堆占用的空间规模相加后不会超过空间限制，也能够显著降低I/O次数。
参考资料：
1.https://dsa.cs.tsinghua.edu.cn/~deng/ds/src_link/pq_complheap/pq_complheap_macro.h.htm
使用了课程代码示例列表中的宏定义写法，并且建堆和下滤的函数名也是保持和讲义中一致
2.参考了提示中的"注意根据内存限制设计合适的读入数据方案",结合fread能大块读取数据的特点进行了读入方案的设计。
三. 时间和空间复杂度的估算。
1.时间复杂度估算
定义变量和通过循环读取前k个元素的时间视为O(k);
    int n, k;
	fread(&n, sizeof(int), 1, stdin);
	fread(&k, sizeof(int), 1, stdin);
	int* data = new int[k];//只维护这k个数字，建立一个大根堆
	fread(data, sizeof(int), k, stdin);
用Floyd法建堆，时间复杂度为O(k);
    heapify(k, data);
    void heapify(int n,int* elem) {//自下而上的下滤，建堆
	    for (int i = (n - 1 - 1) / 2; i >= 0; i--) {
		    percolateDown(n, i, elem);
	    }
	    return;
    }
对于剩下的n-k个元素，逐个和各自对应的堆顶比较，若小于堆顶则和堆顶交换后做下滤。单次下滤的时间复杂度为O(logk)，最坏情况下要下滤n-k次，因此n-k次循环的时间复杂度为O((n-k)*logk)=O(nlogk);
    for (int i = k; i < n; i++) {
		int temp;
		if (pos < 100000)
			temp = left[pos++];
		else {//如果当前这一段读完了就再大块地读100000个整数进来
			fread(left, sizeof(int), 100000, stdin);
			pos = 0;
			temp = left[pos++];
		}
		if (temp < data[0]) {//新元素比堆中最大的元素要小，就把堆顶删了把新元素加进来做一次下滤维护堆的性质
			data[0] = temp;
			percolateDown(k, 0, data);
		}
	}
因此总体时间复杂度T(n)=O(k)+O(k)+O(nlogk)=O(nlogk);
2.空间复杂度的估算
堆的规模为O(k)，整个过程中都是在维护堆的性质从而取到第k大;
后续的n-k个元素若是逐个读取进内存，则辅助的空间可视为常数O(1);

因此整体的空间复杂度=O(k)+O(1)=O(k);

四.理论分析与实测效果的吻合程度
对剩余n-k个数若逐个读进内存操作会在I/O上占用较多时间，若改成一次读100000进内存并先使用完再接着读和使用直到读完，可以明显减少第9和10两个测试点的时间，原因是减少了I/O次数
