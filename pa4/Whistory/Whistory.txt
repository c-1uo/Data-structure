一. 所使用数据结构与算法的构思、原理和实现要点。
1.所使用的数据结构：散列(hash)和串匹配的KMP算法
2.算法的构思、原理和实现要点：首先要解决的问题是对于长度相等的两个串a和b如何判定两者是否能通过循环移位得到。考虑到若将a整体重复一次接在a的末尾得到一个新的字符串c=a+a，若b能通过移位循环得到a等价于:以b为模式串能在文本串c中匹配成功,
反之亦然即匹配失败对应着b不能移位循环得到a的情况。若对于第i个读进来的字符串都和前面的i-1个字符串按照输入顺序逐个比较，则字符串之间比较次数会达到O(m*m)这一级别，平方级别的复杂度是会妥妥超时的。因此需要只对有满足移位循环成立条件潜力的
那些字符串进行比较，又可以发现字符串里字符的ASCII码的总和这一指标对于两个能互相移位循环得到的字符串是一样的，因此可将字符串中的a~z对应到1~26这26个自然数，并且计算出每个字符串中字符对应数字之和作为每个字符串的hash值。这样映射之后可以充分减少
尝试字符串匹配的次数，降低时间成本。
实现要点：1.散列冲突的时候要用KMP算法检验是否匹配，不匹配的话需要为桶加入新的槽位。
2.尝试匹配前需要在文本串的末尾再接一个文本串作为预处理，因此要设置好字符串的长度防止越界。
二. 完成过程中遇到的问题，排除问题的主要过程、使用的方法和技巧，以及参考资料。
问题1：期初是对于第i个读进来的字符串都和前面的所有i-1个字符串按照输入顺序逐个比较，最终超时。因为算术级数是平方级的，时间复杂度退化到了m*m*O(n)。于是采用了散列的方式减少串匹配的次数。
参考资料：
1.https://dsa.cs.tsinghua.edu.cn/~deng/ds/src_link/string_pm_kmp/pm_kmp.cpp.htm
https://dsa.cs.tsinghua.edu.cn/~deng/ds/src_link/string_pm_kmp/pm_kmp_next.cpp.htm
参考了代码示例列表中的kmp算法以及buildNext的模板
2.http://blog.csdn.net/jingsuwen1/article/details/51931464
参考了博客中的移位循环包含问题的两种思路
三. 时间和空间复杂度的估算。
1.时间复杂度估算
定义若干变量和读取n和m的值的时间复杂度为O(1);
    int n, m;
	scanf("%d %d", &n, &m);//车轮周长n,m条轨迹
	int pos = 0;//用来记录后续新插入节点的数量
	char str[1002];
接下来逐个读进来m个字符串，对于每一条字符串而言，都需要先计算出对应的hash值，算hash值的时间复杂度和字符串的长度是成正比的为O(n);
    scanf("%s", str);
    int key = Hash(str);
散列表中hash值对应的桶若为空则需要在相应节点保存下当前字符串输入的次序值，并且说明之前都没有满足循环移位的，输出0。
    if (strcmp(node[key].entry, empty) == 0) {//桶的第一个槽位如果为空，则先在该节点上赋值
		printf("0\n");
		strcpy(node[key].entry, str);
		node[key].index = i + 1;
	}
若对应的桶非空，则需要依次和桶中所有槽位里的字符串尝试串匹配，匹配预处理需要将文本串复制一遍并重复一次接在末尾，预处理的时间成本为2*O(n)，匹配成功则可以输出槽位中存储的次序值并且停止继续比对，若
桶的所有槽位中均匹配失败，则需要为桶添加一个新的槽位并将当前字符串的输入次序值存储在新槽位中。期望意义下散列若是均匀的，
散列表中每个桶对应的槽位为常数c，则至多进行c次KMP算法匹配字符串，单次匹配的时间复杂度为O(2*n+n)。则内循环中每次操作的
时间复杂度为c*O(2*n+n)+O(n)+2*O(n)=O(n)。而外圈循环为m此，因此总的时间复杂度为m*O(n);
            Node *p = &node[key];
			bool exist = false;
			for (p; p != NULL; p = p->next) {
				char text[2005];
				int lengthT = (int)strlen(p->entry);//构造一个新的文本串为T+T，在新串中匹配模式串P，匹配成功说明可以移位循环得到。
				for (int j = 0; j < lengthT; j++)
					text[j] = p->entry[j];
				for (int j = lengthT; j < 2 * lengthT; j++)
					text[j] = p->entry[j - lengthT];
				text[2 * lengthT] = '\0';
				if (match(str, text) == true) {
					exist = true;
					printf("%d\n", p->index);//成功则返回文本串的那个秩
					break;
				}
			}
			if (exist == false) {//桶中所有槽位均无法匹配时则需要新开辟一个槽位
				printf("0\n");
				strcpy(sup[pos].entry, str);//挂载新节点
				sup[pos].index = i + 1;
				(node[key]).insertafter(&sup[pos]);
				pos++;
			}
因此总体期望意义下的时间复杂度T(n)=O(1)+m*O(n)=m*O(n)=O(mn)
2.空间复杂度的估算
散列表的长度是根据字符串的个数来确定的，字符串最多10000条，因此取了小于10000最大的质数9973,期望达到散列尽可能均匀的效果，因此散列表长度为O(m)。而散列表的每一个槽位中若
非空则都会存储一个长度为n的字符串为之后的对比做准备。因此散列表的总体空间复杂度为n*O(m);
辅助使用的用于复制的字符串等变量的空间复杂度视为O(1);

因此整体的空间复杂度=n*O(m)+O(1)=n*O(m)=O(mn);
