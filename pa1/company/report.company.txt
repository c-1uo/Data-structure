一. 所使用数据结构与算法的构思、原理和实现要点。
1.所使用的数据结构：向量(vector)和bitmap
2.算法的构思、原理和实现要点：
第一次思路：在规定了n和m的数量后，由于之后的m行中至多包含3个字符(除空格回车外)，因此可以用一个m*3的字符串数组c存放每一行的信息，再通过每行首字母进行到if分支的判断，如果
判断结果为之后又数字字符输入，则调用字符串转换为数字的函数将每行的员工的id和更新的code分别保存到相应的int类型的数组元素中去。(此步显得较为麻烦，可以采用scanf逐个输入的方式，
但是第一次的思路确实是这样，在后一版本中优化)。用d[m][3]这个数组来存放员工的信息，d[i][1]表示员工的编号，d[i][2]表示员工的code。
实现要点：
如果首字母是I的话，第二个数字赋值给d[i][1]后，则对于之前所有已经输入的员工id都需要和新输入的做一次比对，如果有相同的，则需要把之前已经输入的id对应的两个信息均抹去(代码中采用
置零的方法)，员工数目在相应的基础上不增加，若比对过程中没有发现相同的，则算新加入了一名新员工，员工数量加一。
如果首字母是O的话，仍然需要和d[i][1]之前所有第二个下标为1的元素进行比对，若之前员工id存在，则将之前员工信息均置零，员工数量减一。如果遍历之后没有相同的id，则代表员工还未注册。
如果首字母是C，则之前所有的d[i][i]和d[i][2]都需要置零。
如果首字母是N，此时情况较为简单，只需要输出记录人数的全局变量num就好。
如果首字母是Q，则需要在之前的所有第二个下标为1的元素中顺序搜索与d[i][1]相同的，然后返回相应的code值。
上述算法能够保证整个算法的正确性，但是每一行的读入基本都要做一次和之前所有元素的比对或者搜索，内循环的时间复杂度可以达到O(m),外循环次数为n，总体时间复杂度将会达到m*O(n),估算一下
发现将会超过时间限制。所以第一次按照基本思路测试只有75分。
第二次思路：第一次在判断员工之前是否注册的过程中采用的是遍历比较和搜索的方式，时间成本很高。考虑采用整型数组code[n]一方面来存储员工的编号，另一方面，如果将code数组中全部初始化
为-1来代表员工的未注册状态，则通过一个校验环只需要O(1)的时间就可以知道该名员工当前的状态和code信息。
实现要点：
主要是在每行首字母为I和O的时候改进较大，每次输入的id只需要在对应的code数组中对应的元素是code[id],若值为-1，代表未注册，而若是不为-1，再进行相应的code更新或者是注销的操作。
当首字母是C的时候，则需要将已经修改过的code数组中的元素重新赋值为-1即可，对应的就是所有员工的状态变成未登陆状态。
二. 完成过程中遇到的问题，排除问题的主要过程、使用的方法和技巧，以及参考资料。
问题1：在数据的输入过程中如何将已经按照字符串变量输入的数字字符如何转化成整型，解决方法是上网搜索了相应的atoi函数
问题2：在已经优化过算法的版本中，当输入的元素为C的时候，将已经注册的员工的代码重新赋值为-1这一步的操作当时采用的是用memset赋值的操作。但是过程中如果数据n的个数足够多而已经注册的
成员很少，则在重新赋值的过程中会浪费很多的时间在将已经是-11的元素修改成-1。于是解决方案是将已经修改过code的员工号按照先后顺序存储在另一个数组中，修改的时候则只需要通过一个校验环
通过直接下标对应的方式重置员工的code，赋值过多少重置多少。
参考资料：
1.按照字符串变量输入的数字字符如何转化成整型
https://zhidao.baidu.com/question/270726014.html
2.优化首字母是C的时，给已经修改过状态的员工重置的时候优化算法以减少时间
http://www.pudn.com/Download/item/id/3068274.html
三. 时间和空间复杂度的估算。
1.时间复杂度估算
        char *c;
		c = new char[m];
		int(*d)[3];
		d = new int[m][3];
		int *code;
		code = new int[n];
		int *s;
		s = new int[n];
		int *e;
		e = new int[n];
		int num = 0;
		int sum = 0;
变量的定义过程时间可以视为O(1)
for (int i = 0; i < n; i++) {
			code[i] = -1;
			s[i] = 0;  
			e[i] = 0;
		}
变量循环赋值的时间为O(n)
int k = 0;
		for (int i = 0; i < m; i = i + 1) {
			cin >> c[i];
			if (c[i] == 'I')
			{
				int a = 0;
				cin >> d[i][1] >> d[i][2];
				a = code[d[i][1] - 1];      
				code[d[i][1] - 1] = d[i][2];
				if (a == -1) {
					num++;
					s[k] = d[i][1] - 1;
					k++;
				}
			}

			else if (c[i] == 'O')
			{
				cin >> d[i][1];
				if (code[d[i][1] - 1] != -1) {
					code[d[i][1] - 1] = -1;
					num--;
				}
			}

			else if (c[i] == 'C') {
				for (int i = 0; i < k; i++) {
					code[s[i]] = -1;
				}
				k = 0;
				num = 0;
			}

			else if (c[i] == 'N') {
				e[i] = num;
			}

			else {
				cin >> d[i][1];
				e[i] = code[d[i][1] - 1];
			}
		}
每一次循环内部的5个分支都只涉及常数步骤的赋值和比对，因此n轮循环的时间为O(n)
for (int i = 0; i < m; i++) {
			sum = sum + e[i];
		}
由于输出的结果需要循环的累加，时间为O(n)
所以总体的时间成本为T(n)=O(1)+2O(n)=O(n)
注：
如果采用第一种思路进行代码，则时间复杂度为O(n²)
2.空间复杂度的估算
员工所有的信息都只存储在了以下这些变量中，没有递归这类的步骤，因此总体空间复杂度为O(1)+O(m)+O(n)=O(n)
        char *c;
		c = new char[m];
		int(*d)[3];
		d = new int[m][3];
		int *code;
		code = new int[n];
		int *s;
		s = new int[n];
		int *e;
		e = new int[n];
		int num = 0;
		int sum = 0;
        
四.理论分析与实测效果的吻合程度
提交的代码中，设置了当数据n>1000的时候使用优化过的算法，n小于1000的时候使用顺序遍历的方法，能够时间较少的通过所有测试点。
而只用第二种顺序遍历的代码则在最后两组数据的处理上会超时，与预期相吻合，结果如下图。
