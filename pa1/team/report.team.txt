一. 所使用数据结构与算法的构思、原理和实现要点。
1.所使用的数据结构：向量(vector)和bitmap
2.算法的构思、原理和实现要点：
第一次的思路：三个教练员分别写的选人次序可以存储在三个不同的数组p、q、r中。例如p中选出了元素k，则在p中删除k元素(将k元素之后的元素依次在数组中前移一个位置)，接着用顺序搜索
的方式在q数组中先找到元素k并且删除，最后在r数组中用顺序查找的方法找到k元素并且删除。每次选人三个数组的元素数量均会减少1，所以算法一定会在有限步骤终止。但是这种思路下，每次
选人的操作都需要大量的时间进行元素位置的变化，每一次删除变化时间复杂度都是O(n)。外循环有n轮，所以总体的时间复杂度会是O(n²)的级别。算法虽然正确性能够保证，但是在数据数量非
常大的时候，运行时间会超过限制。
第二次思路：如果每次删除人的时候，在相应的数组中并不直接在内存中真正删除，而是为每个元素增加一个状态的判断。为每次轮到的未被选走的元素增加标记，如果该元素状态被标记成已经删
除，则删除对象跳转到下一个元素直到找到一个之前未被标记为删除元素，并且将其标记。通过常数轮判断一定能找到未被删除的元素。则每个内循环中时间是O(1),总体复杂度是O(n)级别的，时
间成本大大减少。而每个元素只会有两个状态：已选走和未被选走，只需增加一个数组，用0表示为被选走，每次选走将0更新为1即可。实现要点为在每次循环内部都需要映射到表示状态的数组中
进行常数次判断。
二. 完成过程中遇到的问题，排除问题的主要过程、使用的方法和技巧，以及参考资料。
问题1：如何定义一个数组容量非常大的数组，例如题目中的n的上界500000。一开始想不使用动态内存分配的方式，在main函数内部中写int a[500000]的时候会在编译运行的时候报错。于是想解
解决这个问题，便上网搜索解决办法，了解到大型数组可以在全局变量中定义。于是在进入main函数之前定义了大小为5000000的数组则可以编译通过并且运行。
问题2：提示中提示使用memset来初始化数组所用的时间少，但是之前没有使用过，于是上网搜索了memset函数的使用方法
参考资料：
1.如何定义大型数组
https://zhidao.baidu.com/question/1381792074340915140.html
2.如何使用memset函数
http://blog.csdn.net/songuooo/article/details/7819790
3.使用第一种思路在第九和十组测试点时间超过限制后上网搜索了解决办法
http://blog.csdn.net/itismelzp/article/details/49659161
三. 时间和空间复杂度的估算。
1.时间复杂度估算
定义各个变量都是常数个步骤，所需时间为O(1)
    for (int j = 0; j < n; j++) {
		scanf("%d", &a[j]);
	}
	for (int j = 0; j < n; j++) {
		scanf("%d", &b[j]);
	}
	for (int j = 0; j < n; j++) {
		scanf("%d", &c[j]);
	}
三次循环将三个教练员的选人名单赋值到三个数组中，所需时间为O(n)
scanf("%d", &m);
	for (int i = 0; i < n; i++) {
		if (i % 3 == 0) {
			while (d[a[c1]] != 0) { c1++; }
			teamname[a[c1]] = 'A';
			d[a[c1]] = 1;
		}
		else if (i % 3 == 1) {
			while (d[b[c2]] != 0) { c2++; }
			teamname[b[c2]] = 'B';
			d[b[c2]] = 1;
		}
		else {
			while (d[c[c3]] != 0) { c3++; }
			teamname[c[c3]] = 'C';
			d[c[c3]] = 1;
		}
	}
将第几次选人存储在变量i中，根据变量i除以3的余数来确定在为第几个教练员选人，进入内循环后有三个分支，进入分支后则先判断元素是否已经被选走，若未被选走则将
该元素的状态由0修改为1，并且记录下该元素所在的教练员。每次循环中这些操作都在常数步骤内完成，因此n轮循环所需要的时间为O(n)
printf("%c\n", teamname[m]);
最后的输出需要的时间为O(1)
因此总体时间复杂度T(n)=O(1)+O(n)+O(n)+O(1)=O(n)
2.空间复杂度的估算
由于没有采用动态内存分配的方式，a[500000], b[500000], c[500000], d[500001]，teamname[500001]这五个数组的容量大小是固定的，因此总体的空间复杂度是一个
常数N，与输入的n的规模无关
注：如果在main函数内部采用动态内存分配的方式，则总体空间复杂度为O(n)
四.理论分析与实测效果的吻合程度
/*int newnum(int s, int p[500000], int q[500000], int r[500000], int num) {
s = p[0];
for (int j = 0; j < num; j++) {
if (q[j] == p[0])
for (int k = j; k < num; k++) { q[k] = q[k + 1]; }
}
for (int j = 0; j < num; j++) {
if (r[j] == p[0])
for (int k = j; k < num; k++) { r[k] = r[k + 1]; }
}
for (int i = 0; i < num; i++) {
p[i] = p[i + 1];
}
return q[0];
};*/
这段代码是第一种思路下写的，每次删除都可以写成一次函数操作，每次操作中有元素的删除操作，涉及到元素位置的变化，每次操作对应的时间复杂度为O(n)，一直找到选出的元素
与所需要搜索的元素相等为止，有可能需要找n轮，此时用第一种思路时间复杂度为O(n²)，测试时间如下，九和十两个点超时。而改进后的代码时间在n较大时缩短极为明显。



