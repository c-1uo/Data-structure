一. 所使用数据结构与算法的构思、原理和实现要点。
1.所使用的数据结构：图中的拓扑排序（topology sort）
2.算法的构思、原理和实现要点：在题干的题目限制中已经明确了整个图是无环有向图，并且给出了各条边的权重(如果权重相等的情况下取最大的那个)。但是在二级提示中提到了并不是所有的城市都是连通的，也就是说
做整个图做dfs的时候可能要对其中的连通分量做多次DFS，于是可以考虑加入两个虚拟的城市，使得分别与入度为0的城市以及出度为零的城市和它们相连，这样进行拓扑排序的时候就只需要进行一次。而且两个虚拟城市节点之
间一定是有通路的，因此只要找到首末两个城市之间权重之和最大的那条通路即可。和Dikjstra算法中求最短路径的思路类似，本题相当于最短路径的反面，即求图中各点到某一点的最长路径。因此拓扑排序后从序列的终点出发，
反向更新各个城市到其的最长路径(也就是最赚钱的那条路径即可)，最终头结点所能赚的最大值就是整个图能够赚到的最大值。这样只能得到数值还不能得到具体的路径，得到路径还需要正向地从头结点走到尾节点，每经过一个点的
时候都需要比较当前城市到终点的赚钱最大值和其前驱到终点赚钱的最大值，若两者之差的绝对值正好等于当前城市与其前驱之间那条边的权重，说明当前城市一定在最赚钱的那条路径上，否则就找到下一个邻居进行相同的比较。至于
字典序最小的那条，只需要将各个城市的邻居编号做好预处理按照从大到小的顺序记录在邻接表中，正向确定路径的时候遍历邻居的时候会自然保证满足当前城市节点是满足赚钱最多的路径中字典序最小的那个，于是整个路径的
字典序最小也得到了保证。
实现要点：1.在建立整个图的时候不能使用邻接矩阵，因为有十万个点，使用邻接矩阵的时候空间使用超过了题目的要求。因此使用邻接表来完成图的建立。2.做完拓扑排序之后不能直接正向地得到赚钱的最大值和路径，应当先
从终点出发，反向地得到各个点到终点能够赚钱的最大值，然后才能正向地逐个比较筛选。3.为了得到最小的字典序的路径，应该在建立图的时候先对各条边做预处理(排序)，使得顶点节点的各个邻居的排列是有序的，这样能够正向
逐个比较的时候求字典序最小的路径。同时也能够使得dfs后得到的拓扑排序序列也是众多拓扑排序中字典序最小的那一个。
二. 完成过程中遇到的问题，排除问题的主要过程、使用的方法和技巧，以及参考资料。
问题1：对于图中可能存在多个连通分量的情况，对于各个分量都有一个最小字典序的路径，做完若干次拓扑排序之后还要再对这些路径做字典序的比较，这样的情况处理起来不够直观和简洁。于是考虑到可以引入两个虚拟的空节点(与其相连
的边的权重均为0)。
问题2:50%测的时候前几次一直是第十个测试点超时，在不修改大体思路的情况下，考虑到可能是在遍历邻居的时候花费了太多时间。发现找邻居的接口写法是先找到第一个邻居然后逐个搜索下去直到找到当前邻居，再到链表中找到后继，这样
每次都浪费了大量的时间在链表前端进行逐个比对。于是修改为直接调用当前邻居节点中的next指针，O(1)的时间直接指向后继(如果存在的话)。这样就解决了第十个测试点超时的情况。
参考资料：
1.http://blog.csdn.net/jnu_simba/article/details/8866844
参考了上述博客中如何用邻接表完成图的存储结构
2.https://dsa.cs.tsinghua.edu.cn/~deng/ds/src_link/graph/graph_dfs.h.htm
代码中的拓扑排序是参照课程讲义以及代码示例列表中书写
3.参考了文档提示中的并不是所有的城市都相连这一句话，引入头和尾这两个辅助节点使得整个图连通
4.仿照了讲义06 - I5中Dijkstra实现代码的写法，按照拓扑排序得到的序列逆向求出每个城市到终点的赚钱的最大值
三. 时间和空间复杂度的估算。
1.时间复杂度估算
定义变量和通过循环给变量赋值的时间视为O(m);
    int n, m;
	scanf("%d %d", &n, &m);//n个点，m条边
	for (int i = 0; i < m; i++) {
		scanf("%d %d %d", &a[i].b, &a[i].e, &a[i].w);
		out[a[i].b]++;//起点的出度加一
		in[a[i].e]++;//终点的入度加一
	}
接下来对输入的各条边进行排序处理便于去重,时间复杂度为O(mlogm);
int cmp(const void *a, const void *b) {
	Edge *c = (Edge *)a;
	Edge *d = (Edge *)b;
	if ((*c).b < (*d).b)//这里如果按照相同城市发出去的顶点从小到小，那么dfs的时候会从大到小
		return -1;
	else if ((*c).b == (*d).b) {
		if ((*c).e < (*d).e)
			return -1;
		else if ((*c).e == (*d).e) {
			if ((*c).w >(*d).w)//权重按照降序排列便于之后去重的时候选择权重最大的
				return -1;
			else
				return 1;
		}
		else
			return 1;
	}
	else
		return 1;
}
qsort(a, m, sizeof(a[0]), cmp);//先排序处理一下，接下来去重
去重操作和将入度为0的城市和虚拟头结点相连以及将出度为0的城市和虚拟尾节点相连，时间复杂度为O(n)+O(m);
    int k = 0;//记录去重后有多少条边
	for (int i = 0; i < m; ) {//循环结束的时候k记录了去重后边的条数
		int j = i;
		b[k] = a[j]; k++;
		while (j < m&&a[j].b == a[i].b&&a[j].e == a[i].e) {
			j++;
		}
		i = j;
	}
	for (int i = 1; i <= n; i++) {//找到没有入度的点都和编号为0的点相连，权重设置为0，这样保证了整个图都是连通的，便于后续的最小字典序找到，否则还要对多个连通图中的最赚钱路径进行比较
		if (in[i] == 0) {
			b[k].b = 0; b[k].e = i; b[k].w = 0;
			k++;
		}
		if (out[i] == 0) {//找到没有出度的点都和编号为n+1的点相连，权重也设置为0，参考了doc文档中的第一行提示
			b[k].b = i; b[k].e = n + 1; b[k].w = 0;
			k++;
		}
	}
对去重之后和新加入边之后的所有边排序一次，时间复杂度O(mlogm);
    qsort(b, k, sizeof(b[0]), cmp);//对插入图的所有边进行排序，起点相同比终点，终点还相同比较权重，由于去重了，这一步其实不会有起点终点相同的情况。此时一共有k条边
接下来是插边操作，因为采用的是邻接表，时间复杂度O(n+m);
    for (int i = 0; i < k; i++) {
		if (city[b[i].b].firstNbr == nullptr)
			city[b[i].b].firstNbr = new EdgeNode(b[i].e, b[i].w, nullptr);
		else {
			EdgeNode *temp = new EdgeNode(b[i].e, b[i].w, city[b[i].b].firstNbr);//编号越大的邻居会越靠前，因此开始进入递归的时候会比编号小的邻居早
			city[b[i].b].firstNbr = temp;
		}
	}
进行拓扑排序，时间复杂度O(n+m);
    Tsort(0);
得到拓扑排序序列和初始化数组，时间复杂度O(n)
    int *Tsorted = new int[n + 2];
	for (int i = 0; i < n + 2; i++) {
		Tsorted[i] = stack[--stackpos];
	}
	int *priority = new int[n + 2];//这里仿照了讲义06-I5中Dijkstra实现代码的写法，区别在于这里priority表示每个城市到终点的赚钱的最大值而不是最小值
	for (int i = 0; i < n + 2; i++) {
		priority[i] = INT_MIN;//初始化都是“负无穷”
	}
反向遍历邻接表和正向遍历邻接表各一次，时间复杂度为2*O(n+m);
	for (int i = n; i > -1; i--) {//遍历所有的邻居，不断更新当前城市到终点的最长路径长度
		for (EdgeNode *x = city[Tsorted[i]].firstNbr; x != nullptr; x = x->next)
			priority[Tsorted[i]] = max(priority[Tsorted[i]], priority[x->num] + x->weight);
	}
	int *finalpath = new int[n + 2];//记录字典序最小的路径
	int q = 0;//记录路径中元素的个数
	finalpath[q++] = 0;
	for (int i = 0; i < n + 1;) {
		int temp;
		for (EdgeNode *x = city[i].firstNbr; x != nullptr; x = x->next) {//遍历所有的邻居，若满足两个城市到达终点赚钱最大值的差等于邻居之间的赚钱数，则要进行更新
			if (priority[i] == priority[x->num] + x->weight)//邻居在邻接表上都是逆序挂载的，因此要找到最小字典序的那个必须访问完所有邻居
				temp = x->num;
		}//在终点也记录下来后循环终止
		finalpath[q++] = temp;
		i = temp;
	}
循环输出，时间复杂度O(n);
    for (int i = 1; i < q - 1; i++)
		printf("%d ", finalpath[i]);

因此总体时间复杂度T(n)=O(m)+O(mlogm)+O(n)+O(m)+O(mlogm)+4*O(n+m)+2*O(n)=O(mlogm)+O(n+m);
2.空间复杂度的估算
整个邻接表的空间复杂度为O(n+m);
开了若干个数组分别来存储边的入度和出度，如：int in[100005];int out[100005]，空间复杂度为O(n);
记录拓扑排序序列和各个顶点到终点最赚钱数目以及最终的路径序列都是开的数组如：int stack[100005];int *priority = new int[n + 2];int *finalpath = new int[n + 2]
这里空间复杂度为O(n);
记录边的信息的时候存储在结构体中Edge a[1000050];Edge b[1300000]，这里空间复杂度为O(m);

因此整体的空间复杂度=O(n+m)+2*O(n)+O(m)=O(n+m);
四.理论分析与实测效果的吻合程度
枚举邻居的时候要直接利用邻接表的特点寻找链表的直接后继得到，不能先找到firstNbr然后再逐个寻找，否则虽然部分测试点不会受影响但是最后一个会超时。如下图。
