一. 所使用数据结构与算法的构思、原理和实现要点。
1.所使用的数据结构：栈（stack）
2.算法的构思、原理和实现要点：整个火车的调度问题可以视为栈混洗(stack permutation)的过程，总体规则上呈现出A中栈顶的元素弹出压入S或者直接压入B，B中的栈顶元素弹出
并且压入S中，题目的要求是最终B栈中的元素从栈底到栈顶呈现从小到大顺序排列的情况。因此不失一般性，可以构造三个线性的数组来存储三个栈中的元素，并且把A栈和B栈的容量设
定为n，而中转栈的容量设定为m。
实现要点：1.对于每一次的操作，都是将A中的栈顶元素和B中的栈顶元素进行比较，为了方便起见可以在B栈中事先压入元素0，这样可以方便压入第一个元素1，如果A
中栈顶元素正好比B栈的栈顶元素大1，则直接将A的栈顶弹出并且压入B栈，对应了输出中的'P';如果S的栈顶元素比B栈顶的元素大1，则弹出S的栈顶元素并且将其压入B中，对应了输出
中的‘O’；相反如果A和S的栈顶元素都不满足压入B的要求，则将A中栈顶弹出并且压入S中，对应了输出中的'I'。整个过程中首先要保证S栈不会溢出，一但溢出可以设置一个break跳出后
续的循环并且输出'NO'。2.如果S在过程中一直不会有溢出情况，则在某一个时刻A中的元素将会全部弹出成为空栈，所有的元素都在B和S两个栈中，B中元素为已经有序的部分(空栈也视为有序)，
要是最终的B中完全有序，记录此时的B栈中栈顶元素B.top()，S中从栈顶到栈底必须是Btop()+1~n的顺序排列才能通过一系列的'O'操作使得整体有序。因此此时要进行一个S栈中元素的遍历，
一旦发现逆序存在即可跳出并且输出'NO'。只有完全压入B后才能保证整个栈混洗过程能够顺利完成。
二. 完成过程中遇到的问题，排除问题的主要过程、使用的方法和技巧，以及参考资料。
问题1：对于算法在整个过程中'NO'何时输出思考了比较久，对于中间栈S可能会爆掉这一点很快地能够想到，但是对于另外一种输出'NO'的情况：A变空，B中有序，S中无序的情况是通过归纳法得到的，因为A中的元素
要么进入B要么进入S，总体A中的元素一直在减少，虽然中途可能有S的元素进入B的情况会保持一段时间内A中的元素数量保持不变，但是B中元素的来源也是A，因此把握了这个大趋势后，就可以
找到A变空的那个节点进行判断。
参考资料：
1.pa-book中setvbuf函数的使用。
2.温习了讲义中04-E中栈混洗一节的内容，其余全部是自行完成没有参考其余资料。
三. 时间和空间复杂度的估算。
1.时间复杂度估算
定义数据类型变量n和m和赋值的步骤视为O(1),再动态内存分配4个整型数组和1个字符数组，A、B、C三个数组保存栈混洗过程中三个栈里的元素，num保存输出元素，way保存对应每次操作的种类(I、O、P)
    int n, m;
	scanf("%d %d", &n, &m);
	int *A = new int[n + 1];
	int *B = new int[n + 1];
	int *S = new int[m + 1];
	int *num = new int[3 * n];
	char *way = new char[3 * n];
这几声明变量且初始化外加给栈A循环赋值的过程时间复杂度视为O(n)+O(1)
    int k = 0;/*记录第一次循环的次数*/
	bool able = true;/*判断栈S是否已经溢出*/
	A[0] = 0;/*每个栈中都给一个起始的0元素充当哨兵，防止在取顶操作时发生数组越界*/
	B[0] = 0;
	S[0] = 0;
	int topa = 1, topb = 0, tops = 0;
	for (int i = 1; i < n + 1; i++) {
		scanf("%d", &A[i]);
	}
接下来的这一个while循环操作是将A栈所有元素弹出(如果可以的话)，在中途可能因为S爆掉而中断，最坏的情况也莫过于先将A中元素整体迁移到S中，再将S中元素迁移到B中，因此这个循环体时间复杂度的上界是2*O(n)
    while (topa < (n + 1)) {
		bool a = (A[topa] == B[topb] + 1);
		bool b = (S[tops] == B[topb] + 1);
		bool c = (A[topa] != B[topb] + 1) && (S[tops] != B[topb] + 1);
		if (a==true) {
			B[topb + 1] = A[topa];
			k++;
			num[k] = A[topa];
			way[k] = 'P';
			topb++;
			topa++;
		}
		if (b==true) {
			B[topb + 1] = S[tops];
			k++;
			num[k] = S[tops];
			way[k] = 'O';
			topb++;
			tops--;
		}
		if(c==true) {
			if (tops == m) {
				able = false;
				break;/*栈爆掉则跳出循环*/
			}
			else {
				S[tops + 1] = A[topa];
				k++;/*k记录循环体的执行次数*/
				num[k] = A[topa];
				way[k] = 'I';
				tops++;
				topa++;
			}
		}
	}
接下来先是遍历S中的元素判断是否有序，所需时间O(n)；如果有序则需要将S中所有元素弹出压入B，也需要O(n)的时间；最终还需要两次循环输出，又需要2*O(n)的时间，这些步骤加起来为4*O(n)
    if (able == false) {
		printf("No");
	}
	else {
		bool sorted = true;
		int temp;
		for (int i = 1; i < tops; i++) {
			if (S[i] < S[i + 1]) {
				temp = S[i];
				S[i] = S[i + 1];
				S[i + 1] = temp;
				sorted = false;
			}
		}
		if (((S[tops] == B[topb] + 1) && (sorted == true))||(tops==0) == true) {
			for (int i = k + 1; i <= k + tops; i++) {
				num[i] = S[1 + tops - i + k];
				way[i] = 'O';
			}
			for (int i = 1; i <= k + tops; i++) {
				printf("%d %c\r\n", num[i], way[i]);
			}
		}
		else
			printf("No");
	}
因此总体时间复杂度T(n)=O(1)+O(n)+2*O(n)+4*O(n)=O(n)

2.空间复杂度的估算
所有的数据变量都存储在了5个动态内存分配出来的数组中，因此空间复杂度为O(n)+O(n)+O(n)+3*O(n)+3*O(n)=O(n)
四.理论分析与实测效果的吻合程度
由于动态开辟出来的存储空间是根据输入数据的规模确定的，因此数据规模越大，如果能完成栈混洗的话(中间不输出'NO'),算法需要的时间越多，存储空间也越大，9成测中的呈现的大体趋势就是如此。
整体所需时间也特别少在50ms这个水平，和要求中n不超过100000也吻合。
