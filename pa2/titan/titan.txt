一. 所使用数据结构与算法的构思、原理和实现要点。
1.所使用的数据结构：两个栈（stack）实现一个队列(queue)
2.算法的构思、原理和实现要点：先将整个问题分解成两个子问题，首先要完成一个队列，其次要提供队列的一个getmax()函数接口。先考虑对于一个栈来说，在压栈(push)和弹出栈顶(pop)的过程中添加一个记录当前
栈中最大值的getmax()函数接口，最简单的办法就是在栈的成员中再加入一个"影子栈"，如果是用数组来存储栈中的元素，相应地就是开辟出相同大小的一个数组，每当有压栈的操作时，就让即将被压进栈的元素和辅助
数组中的最后一个元素(相当于影子栈的栈顶元素)进行比较，如果即将入栈的元素更大，则相应地需要将即将入栈的元素也压入辅助栈中；如果即将入栈的元素小于当前栈内最大值，则吧当前辅助栈的栈顶元素复制一份
再一次将它压入辅助栈。对于pop()的操作正好和压入相反。这样的话就能够在栈的内部完成一个取最大值的函数接口，并且每次对于当前栈查找最大值时间复杂度都是O(1)。这只是完成了一般的工作，接下来就是如何用
两个栈来实现一个队列，假设有一个栈A和一个栈B，初始状态都为空，碰到入队的指令就把相应的元素压入A中，直到碰上出队的指令，就要将A中的栈顶逐个弹出并且逐个压入B栈中，过程终止后将B的栈顶元素pop()出来
就完成了出列的操作，之后入列时还是压入A，出列的时候就可以直接在B中执行pop()直到B中为空，如果还要出列就重新执行将A中的栈顶逐个弹出并且逐个压入B栈中这个操作。虽然从A中逐个弹出并且压入B这个过程的
时间复杂度可能达到O(n),但是对于接下来的n次出列，每次都只需要O(1)时间，从分摊复杂度的角度考虑每次出列所需要的时间也是O(1),于是也完成了用两个栈实现队列的要求，而栈内也提供了取最大值的函数接口，所
以整个问题得到解决。
实现要点:
1.在写栈类的public成员中增加一个辅助数组存储最大值，再提供一个函数接口getmax()能够获得最大值
2.用两个栈的push()和pop()操作来实现入列和出列
二. 完成过程中遇到的问题，排除问题的主要过程、使用的方法和技巧，以及参考资料。
问题1：最开始审题的时候对于利威尔兵长在队列为空的时候是否会发出'D'或者'M'这两个指令不太明确，于是自行假设了如果在队列为空的时候需要返回最大值，由于队列中没有战士，就会返回0。这个假设就导致后面的
测试点一直有过不去的情况。后面重新审题后去掉了这个假设，并且还重新考虑了可能插入队列的有负战力的士兵，从而解决了这个问题。
参考资料：
1.pa-book中setvbuf函数的使用。
2.讲义中04-XA中steap这一节的内容，实现栈在更新的过程中记录最大值。
3.http://ishare.iask.sina.com.cn/f/18359238.html
为了实现队列中取得最大值的时间从O(n)的复杂度降低为O(1),参考了《编程之美》一书中3.7队列中取最大值操作问题的解法
4.http://blog.csdn.net/itismelzp/article/details/49658873
在两个栈取最大值得时候一开始是两个栈各自取max比较之后输出更大的那个，这样会使得两个栈中空或非空的情形下边界情况处理不准确，于是借鉴了这个博客中的碰见指令'M'时的处理：有空的栈就先把元素往空栈中转移一遍。
三. 时间和空间复杂度的估算。
1.时间复杂度估算
声明变量并且初始化并且部分完成赋值的过程视为O(1)
    int n;//记录命令行数
	int abi;//记录能力值
	scanf("%d", &n);
	stack s1(n), s2(n);
	char empty;
	scanf("%c", &empty);
	char order;
接下来每一行代表依次循环，所以外循环的次数是n。对于内循环来说：当碰到'E'命令的时候，对应的是压栈的操作，常数步骤内可以完成，复杂度是O(1)；对于'D'这个指令，虽然说在某些最差的情况下s1这个栈内所有的
成员都会pop出来并且push进s2这个栈，最差情况下复杂度可以达到O(n),但是对于接下来的n-1次'D'命令就可以直接通过O(1)的时间完成，因为只需要在s2中进行一次pop操作，按照分摊复杂度的思想，每一次出列的时间
复杂度也是O(1);对于碰到'M'这个指令，栈的转移这个过程和出列一样，两个栈各调用一次getmax()函数，比较一下返回更大的那个，也是常数步骤内完成。因此这三种情况对应的内循环的时间复杂度在分摊的角度来说都是
O(1)。所以n次外循环后时间复杂度为O(n)。
    for (int i = 0; i < n; i++) {
		scanf("%c", &order);
		if (order == 'E') {
			scanf("%d", &abi);
			s1.push(abi);
			//实现求栈s1的最大值
		}
		else if (order == 'M') {
			if (s2.empty() == true) {
				while (s1.empty() == false) {
					s2.push(s1.pop());
				}
			}
			if (s1.empty() == true) {
				printf("%d\n", s2.getmax());
			}
			else {
				int max1 = s1.getmax();
				int max2 = s2.getmax();
				int max = max1 > max2 ? max1 : max2;
				printf("%d\n", max);//由于取最值没有队列的插入或者出列，因此只要比较构成队列的两个栈的最大值，并且取较大的那个返回
			}
		}	
		else {
			if (s2.empty() == true) {
				while (s1.empty()==false) {
					s2.push(s1.pop());
				}
			}
			printf("%d\n", s2.pop());//出队列相当于元素在两个栈中转移后，队首从栈底变成了栈顶，只需要pop出转以后的栈顶元素即可
		}
		scanf("%c", &empty);
	}
   
因此总体时间复杂度T(n)=O(1)+O(n)=O(n)

2.空间复杂度的估算
所有的元素都存储在了2个栈中，而这两个栈中各自有两个数组分别存放元素本身和记录最大值，每个数组的规模都和于命令的次数正相关，因此空间复杂度为O(n)+O(n)+O(n)+O(n)=4*O(n)=O(n)
四.理论分析与实测效果的吻合程度
如果在不实时记录下栈中最大值来降低每次取最大值的复杂度为O(1),而是在每次取最大值的时候都暴力循环一遍，那时间复杂度会上升到平方级别，虽然在5成测试中体现不出来，在9成测试中就会有最后两个点超时。改进以后
则能够实现显著的降低时间成本。
