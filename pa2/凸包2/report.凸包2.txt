一. 所使用数据结构与算法的构思、原理和实现要点。
1.所使用的数据结构：栈（stack）
2.算法的构思、原理和实现要点：整个算法的构思是建立在完整阅读了GrahamScan算法步骤后得到的。首先必须找到开始构建整个凸包的起始点，这个起始点是y坐标最小的那些点里x坐标
最小的那个，之所以去这个点为基准点是因为这样一来剩下的所有点都不会在它的下面，使得其它点相对于基准点的极角在[0,180)这样一个范围内，便于按照极角排序的步骤。接下来通过
计算叉积的值通过叉积正负号来给其余的点按照极角从小到大排序：当两个点极角不相等的时候，小的在前大的在后；当两个点的极角相同时，则进一步比较这两个点相对于基准点的距离。距
基准点更近的那个排在前面，如果连距离也相等则为重复出现的点，此时考虑到算法的稳定性按照排序前出现的次序进行排序。所有的点经过排序后则开始凸包上点的筛选，整个过程是逆时针
的，显然选取的基准点一定在凸包上，此时可以通过一个栈来容纳在凸包上的点。先将排序后的基准点以及第二个点压入栈，以栈中仅次于栈顶的点作为向量的起始点P，栈顶的点作为其中一个
向量的终点A，此时取还未进栈的第一个点作为另一个向量的终点B，计算向量PB和PA的叉积。如果结果大于等于0，则说明B和PA共线或者B已经是一个凹进去的点了，此时与凸包要求矛盾，因此
需要弹出栈顶的元素，将刚才的B点压入栈中，并且进入循环；如果叉积小于0，则说明此时的栈顶元素一定在凸包的顶点上不用将其弹出，紧接着将B入栈并且进入循环。循环结束时栈中所保留的
所有点就是凸包顶点上面的点。
实现要点：
1.按照极角从小到大排序是整个算法中时间复杂度的主要贡献部分，其中还要考虑到点的重合和向量的共线问题。
2.所有点已经排序完成后开始入栈筛选的过程需要逐个判断是否为凸包顶点。
二. 完成过程中遇到的问题，排除问题的主要过程、使用的方法和技巧，以及参考资料。
问题1：第一次提交后虽然9成测全部通过，但是worst case情况下耗时达到了800ms，担心全集测试时候剩下的两个点可能会超时，所以考虑优化算法。解决思路是整个算法中排序是最主要的部
分之一，一开始使用的是归并排序，并且是以讲义中的代码为模板，于是考虑换成stdlib.h中的qsort函数，时间降低到了600ms左右。虽然两个算法时间复杂度都是n(logn)这个级别的，但是在
前面的常数项上有偏差。
问题2：排序完毕后对于重复的点和共线的点会不会影响到之后点的入栈没有十足把握，于是在入栈前先后进行了去重和去共线(在极角相同的情况下只取相对于基准点最远的点)两步操作，使得入栈
操作时候所有的点都是互异的并且每个极角上至多只有一个点，这样虽然能够有十足的把握在最后点的入栈操作中正确，但是代码显得冗长，并且去重的和去共线都是O(n)时间复杂度的，时间成本上也
颇为浪费。于是考虑去掉这两个步骤，仔细分析后发现去掉是没有问题的，在叉积的判断时只要叉积大于等于0，栈顶就需要pop出来，等于0的情况就是共线的情况，pop的操作就相当于舍弃了距离基准点
更近的那个点，而重复出现的点也可以视为共线的特殊情况，并且题干中保证了凸包的存在，因此去掉这两步操作时完全可行的。并且时间成本由600ms降低到了500ms。
问题3：虽然考虑到了再计算叉积的过程中int类型的整数可能会溢出，采用了long long类型来存储叉积，但是5成测试中一直有一个点过不去，进行9成测试发现后一半也有三个测试点过不去。检查其余
算法无误的情况下开始考虑是不是数据类型转换的时候发生了错误，于是通过阅读pa-book发现之前计算距离的时候写的是类似于long long dis=x*x+y*y;这样的表达式，其中x和y都是int型，这样会把
溢出后的值给long long类型的变量，于是在每个运算数的前面都加上了(long long)先进行类型转换。
参考资料：
1.http:\\baike.baidu.com\view\707209.htm
在一级提示给出的链接中了解了凸包的背景知识
2.http://blog.csdn.net/bone_ace/article/details/46239187
在这个博客中了解了5中不同的凸包的求解算法
3.http://m.blog.csdn.net/tmljs1988/article/details/7259331
阅读了这个博客文章中详细的GrahamScan算法的思路和步骤
4.pa-book中的setvbuf函数用法，题干中fread函数的用法，以及第一版代码中排序使用的是讲义中mergesort的模板
三. 时间和空间复杂度的估算。
1.时间复杂度估算
定义数据类型变量n，以及通过fread函数给每个点的x坐标和y坐标赋值，这一系列操作的时间复杂度为O(n)+O(1)
    int n;
	fread(&n, sizeof(int), 1, stdin);//参考了提示中的fread用法
	point *p;
	p = new point[n];
	for (int i = 0; i<n; i++) {
		fread(&p[i].x, sizeof(int), 1, stdin);
		fread(&p[i].y, sizeof(int), 1, stdin);
	}
接下来通过遍历整个点的序列挨个比较，确定出整个凸包开始扫描的基准点，时间复杂度是O(n)
    ori = 0;
	orix = p[0].x;
	oriy = p[0].y;
	for (int i = 0; i < n; i++) {
		if (p[i].y < oriy) {
			ori = i;
			orix = p[i].x;
			oriy = p[i].y;
		}
		else if (p[i].y == oriy) {
			if (p[i].x < orix) {
				ori = i;
				orix = p[i].x;
				oriy = p[i].y;
			}
		}
	}
按照极角(极角相同时比距离)从小到大排序，使用的是库函数里的qsort函数，时间复杂度是O(nlogn)	
    qsort(p, n, sizeof(p[0]), cmp);
之后可以通过一个数组来模拟栈的动态变化过程，每个点判断的时间都是常数步骤内完成的，总共判断n个点，时间复杂度为O(n)
    point *q = new point[n];//q相当于一个栈
	int top = -1;
	q[0] = p[0]; ++top;
	q[1] = p[1]; ++top;
	for (int i = 2; i<n; i++) {
		while (vec(p[i], q[top], q[top-1]) >= 0 && top >= 1) {//凹进去或者共线时候等价于将栈顶元素弹出，但保证栈里最底下两个元素不变
			--top;
		}
		q[++top] = p[i];
	}
循环输出视为O(n)
    for (int i = 0; i <= top; i++) {
		printf("%d %d\n", q[i].x, q[i].y);
	}
所以总体的时间复杂度T(n)=O(n)+O(1)+O(n)+O(nlogn)+O(n)+O(n)=O(n)+O(nlogn)
2.空间复杂度的估算
所有的点的坐标都存储在了2个动态内存分配出来的结构体数组中，其余的函数中的局部变量视为O(1)的话，空间复杂度为2*O(n)+O(1)=O(n)
四.理论分析与实测效果的吻合程度
使用归并排序的代码如下
void merge(int lo, int mi, int hi, point *elem, int x, int y) {
	point *A = elem + lo;
	int lb = mi - lo;
	point *B = new point[lb];
	for (int i = 0; i < lb; i++) {
		B[i] = A[i];
	}
	int lc = hi - mi;
	point *C = elem + mi;
	for (int i = 0, j = 0, k = 0; j < lb || k < lc;) {
		if (j < lb && (lc <= k || pos(B[j], C[k], x, y) == 1))
			A[i++] = B[j++];
		else if (k < lc && (lb <= j || pos(B[j], C[k], x, y) == -1))
			A[i++] = C[k++];
	}
	delete[] B;
}
void mergesort(int lo, int hi, point *elem, int x, int y) {
	if (hi - lo < 2)
		return;
	int mi = (lo + hi) / 2;
	mergesort(lo, mi, elem, x, y);
	mergesort(mi, hi, elem, x, y);
	merge(lo, mi, hi, elem, x, y);
}
此题中归并排序在9成测试中时间比快速排序时间要更长，并且删掉处理重复点和共线点的代码后时间进一步优化

